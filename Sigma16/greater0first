;int possum=0;
;int n;
;int negcount=0;
;int oddcount=0;
;bool overflow=false;
;for(int i=0;i<n;i++)
;{
;    if(x[i]<0)
;	negcount++;     
;    else if(x[i]>0)
;    {
;        possum+=x[i];
;        if(possum<0)
;            overflow=true;
;        if(x[i]&1!=0)
;            oddcount++;
;    }        
;}
;REGISTER USAGE
;R1=I
;R2=N
;R3=CONSTANT 1
;R4=POSSUM
;R5=NEGCOUNT
;R6=ODDCOUNT
;R7=X[I]
;R8=OVERFLOW 
;R9=TEMP BOOL AND TEMP AND RESULT
;INITIALISATION
	LEA	R1,0[R0]	;SET I INITIAL 0
	LOAD	R2,N[R0]	;SET N TO R2
	LEA	R3,1[R0]	;SET CONSTANT 1 TO R3
	LEA	R4,0[R0]	;SET POSSUM INITIAL 0
	LEA	R5,0[R0]	;SET NEGCOUNT INITIAL 0
	LEA	R6,0[R0]	;SET ODDCOUNT INITIAL 0
	LEA	R8,0[R0]	;SET OVERFLOW TO 0(FALSE) INITIALLY
;MAINLOOP
LOOP	CMPGT	R9,R2,R1	;IF I<N
	JUMPF	R9,DONE[R0]	;IF I!<N,GOTO DONE
	LOAD	R7,X[R1]	;LOAD X[I]
	CMPEQ	R9,R7,R0	;IF X[I]=0
	JUMPT	R9,SKIP3[R0]	;IF X[I]=0,GOTO SKIP3
	CMPLT	R9,R7,R0	;IF X[I]<0
	JUMPT	R9,SKIP1[R0]	;IF X[I]<0, GOTO SKIP1
	ADD	R4,R4,R7	;POSSUM+=X[I]
	CMPLT	R9,R4,R0	;IF POSSUM<0
	JUMPF	R9,SKIP2[R0]	;IF POSSUM!<0(NOT OVERFLOW), GOTO SKIP2
	LEA	R8,0[R9]	;SET OVERFLOW TRUE
SKIP2	AND	R9,R7,R3	;X[I] AND 1
	JUMPF	R9,SKIP3[R0]	;IF EVEN, GOTO SKIP3
	ADD	R6,R6,R3	;ODDCOUNT++
	JUMP	SKIP3[R0]	;GOTO SKIP3
SKIP1	ADD	R5,R5,R3	;NEGCOUNT++
SKIP3	ADD	R1,R1,R3	;I++
	JUMP 	LOOP[R0]	;GO BACK TO LOOP
DONE	STORE	R4,POSSUM[R0]
	STORE	R5,NEGCOUNT[R0]
	STORE	R6,ODDCOUNT[R0]
	STORE	R8,OVERFLOW[R0]	;STORE 4 VARIABLES
	TRAP	R0,R0,R0	;END
;DATA AREA
X		DATA	3
		DATA	-6
		DATA	27
		DATA	101
		DATA	50
		DATA	0
		DATA	-20
		DATA	-21
		DATA	19
		DATA	6
		DATA	4	
		DATA	-10	;SET X[0~N-1]
N		DATA	12	;SET N=12
POSSUM		DATA	0
NEGCOUNT	DATA	0
ODDCOUNT	DATA	0
OVERFLOW	DATA	0